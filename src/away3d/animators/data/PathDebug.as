package away3d.animators.data{	import flash.display.BitmapData;		import away3d.core.base.Vertex;	import away3d.animators.data.Path;	import away3d.animators.data.CurveSegment;	import away3d.containers.Scene3D;	import away3d.containers.ObjectContainer3D;	import away3d.primitives.CurveLineSegment;	import away3d.primitives.Sphere;	import away3d.materials.WireframeMaterial;	import away3d.materials.BitmapMaterial;		/**	 * displays the path information	 */    public class PathDebug    {        private var _path:Path;		private var _scene:Scene3D;		private var _displayAnchors:Boolean = true;		private var _showPath:Boolean = true;				public var _container:ObjectContainer3D;		private var _aCurves:Array;		private var _aSpheres:Array;		private var _matline:WireframeMaterial;		private var _matsphere:BitmapMaterial;		private var _matspherecontrol:BitmapMaterial;		 		/**		 * Creates a new <code>PathDebug</code> object.		 * @param	 scene		Scene3D. The scene to addchild the visualisation of the Path object		 * @param	 path			Path. The Path object to be displayed		 */        public function PathDebug(scene:Scene3D, path:Path)        {			_scene = scene;			 _path = path;			_matline= new WireframeMaterial( 0xFFFF99, {width:0});			_matsphere = new BitmapMaterial(new BitmapData(64,64,false, 0x00ff00));			_matspherecontrol = new BitmapMaterial(new BitmapData(64,64,false, 0xFF9900));			_container = new ObjectContainer3D();			_aCurves = [];			_aSpheres = [];			var loop:int = _path.aSegments.length;			var v0:Vertex;			var vc:Vertex;			var v1:Vertex;			var cs:CurveSegment;			var cls:CurveLineSegment;			 			for(var i:int = 0; i<loop; ++i){				cs = _path.aSegments[i];				v0 = new Vertex(cs.v0.x, cs.v0.y, cs.v0.z);				vc = new Vertex(cs.vc.x, cs.vc.y, cs.vc.z);				v1 = new Vertex(cs.v1.x, cs.v1.y, cs.v1.z);								cls = 	new CurveLineSegment(v0, vc, v1, _matline);				_aCurves.push(cls);				_container.addChild(cls);								addAnchor(v0, _matsphere);								addAnchor(vc, _matspherecontrol);									if(i == loop-1)					addAnchor(v1, _matsphere);			}						_scene.addChild(_container);		}				private function addAnchor(position:Vertex, mat:BitmapMaterial):void		{			var sphere:Sphere = new Sphere({material:mat, radius:50, segmentsH:2, segmentsW:2 });			_aSpheres.push(sphere);			sphere.x = position.x ;			sphere.y = position.y ;			sphere.z = position.z ;			_container.addChild(sphere);		}		/**		 * Defines if the anchors must be displayed in debugmode. if false, only curves are displayed		 */		public function set showAnchors(b:Boolean):void		{			if(!_container)				return;							_displayAnchors = b;			var i:int			var loop:int = _aSpheres.length;			for(i = 0;i<loop;++i)				_aSpheres[i].visible = b;		}				public function get showAnchors():Boolean		{			return _displayAnchors;		}				/**		 * defines if the path data must be visible or not when path debug		 */		public function set display(b:Boolean):void		{			if(!_container)				return;							_showPath = b;			_container.visible = false;		}				public function get display():Boolean		{			return _showPath;		}				/**		 * Removes and destroys the path visualisation		 */		public function clearDebug(b:Boolean):void		{			if(!_container)				return;							var i:int			var loop:int = _aSpheres.length;			for(i = 0;i<loop;++i)				_container.removeChild(_aSpheres[i]);				_aSpheres[i] = null;						loop = _aCurves.length;			for(i = 0;i<loop;++i)				_container.removeChild(_aCurves[i]);				_aCurves[i] = null;							_scene.removeChild(_container);			_container = null;			_aSpheres = _aCurves = [];		}		// to be updated with prefab code...		public function updateAnchorAt(index:int):void		{		}    }}