package away3d.tools.utils{	import away3d.core.math.Number3D;	import away3d.core.base.Vertex;	import away3d.core.base.UV;		/**	 * Classe returns the uv's from a Number3D on a triangle plane defined with Vertex objects. Null if outside the triangle definition	 * This class was made to allow uv retreiving from a hittest in BSP projects using the BSPHitTest.getUVIntersectPosition method	 */		public class BaryCentricTest	{		private static var _bv0:Vertex;		private static var _bv1:Vertex;		private static var _bv2:Vertex;		private static var _uv:UV;				/**		 * Returns the uv's from a Number3D on a triangle plane defined with Vertex objects. Null if outside the triangle definition		 *		 * @param	v0		Vertex. The face v0		 * @param	v1		Vertex. The face v1		 * @param	v2		Vertex. The face v2		 * @param	uv0	UV. The face UV uv0		 * @param	uv1	UV. The face UV uv1		 * @param	uv2	UV. The face UV uv2		 * @param	hit		Number3D. The intersect point on triangle plane		 */		public static  function getUVs(v0:Vertex, v1:Vertex, v2:Vertex, uv0:UV, uv1:UV, uv2:UV, hit:Number3D):UV		{			if(_bv0 == null){				_bv0 = new Vertex(0.0,0.0,0.0);				_bv1 = new Vertex(0.0,0.0,0.0);				_bv2 = new Vertex(0.0,0.0,0.0);				_uv = new UV(0.0,0.0);			}			 			_bv0.x = v2.x - v0.x;			_bv0.y = v2.y - v0.y;			_bv0.z = v2.z - v0.z;						_bv1.x = v1.x - v0.x;			_bv1.y = v1.y - v0.y;			_bv1.z = v1.z - v0.z;						_bv2.x = hit.x - v0.x;			_bv2.y = hit.y - v0.y;			_bv2.z = hit.z - v0.z;			 			// Compute dot products			var dot00:Number = _bv0.x*_bv0.x+_bv0.y*_bv0.y+_bv0.z*_bv0.z;			var dot01:Number = _bv0.x*_bv1.x+_bv0.y*_bv1.y+_bv0.z*_bv1.z;			var dot02:Number = _bv0.x*_bv2.x+_bv0.y*_bv2.y+_bv0.z*_bv2.z;			var dot11:Number = _bv1.x*_bv1.x+_bv1.y*_bv1.y+_bv1.z*_bv1.z;			var dot12:Number = _bv1.x*_bv2.x+_bv1.y*_bv2.y+_bv1.z*_bv2.z;						// Compute barycentric coordinates			var invDenom:Number = 1 / (dot00 * dot11 - dot01 * dot01);			var s:Number = (dot11 * dot02 - dot01 * dot12) * invDenom;			var t:Number = (dot00 * dot12 - dot01 * dot02) * invDenom;						if(s > 0.0 && t > 0.0 && (s + t) < 1.0){				_uv.u = uv0.u+s*(uv2.u-uv0.u)+t*(uv1.u-uv0.u);				_uv.v = uv0.v+s*(uv2.v-uv0.v)+t*(uv1.v-uv0.v);			} else{				return null;			}						return _uv; 		}	}}