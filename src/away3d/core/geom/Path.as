package away3d.core.geom{	import away3d.core.math.*;		import away3d.containers.*;		/**	 * Holds information about a single Path definition.	 */    public class Path    {		/**    	 * To display/debug the Path instance data    	 */		public var _pathDebug:PathDebug;		    	/**    	 * The array that contains the path definition.    	 */        public var aSegments:Array;				/**    	 * The worldAxis of reference    	 */		public var worldAxis:Number3D = new Number3D(0,1,0);    			        private var _smoothed:Boolean;		/**    	 * returns true if the smoothPath handler is being used.    	 */		public function get smoothed():Boolean		{			return _smoothed;		}				private var _averaged:Boolean;		/**    	* returns true if the averagePath handler is being used.    	*/		public function get averaged():Boolean		{			return _averaged;		}		/**		 * Creates a new <code>Path</code> object.		 * 		 * @param	 aVectors		[optional] An array of a series of number3D's organized in the following fashion. [a,b,c,a,b,c etc...] a = v1, b=vc (control point), c = v2		 */		         public function Path(aVectors:Array = null)        {			if(aVectors!= null && aVectors.length < 3)				throw new Error("Path array must contain at least 3 Number3D's");			            this.aSegments = [];						if(aVectors != null)				for(var i:int = 0; i<aVectors.length; i+=3)					this.aSegments.push( new CurveSegment(aVectors[i], aVectors[i+1], aVectors[i+2]) );			         }				/**		 * display the path in scene		 */		public function debugPath(scene:Scene3D):void        {			_pathDebug = new PathDebug(scene, this);        }		/**		 * Defines if the anchors must be displayed if debugPath has been called. if false, only curves are displayed		 */		public function get showAnchors():Boolean        {			if(!_pathDebug)				throw new Error("Patheditor not set yet! Use Path.debugPath() method first");							return _pathDebug.showAnchors;		}		public function set showAnchors(b:Boolean):void        {			if(!_pathDebug)				throw new Error("Patheditor not set yet! Use Path.debugPath() method first");						_pathDebug.showAnchors = b;        }		/**		 * Defines if the path data must be visible or not if debugPath has been called		 */		public function get display():Boolean        {			return _pathDebug.display;		}		public function set display(b:Boolean):void        {			if(!_pathDebug)				throw new Error("Patheditor not set yet! Use Path.debugPath() method first");						_pathDebug.display = b;        }				 		/**		 * adds a CurveSegment to the path		 * @see CurveSegment:		 */		public function add(cs:CurveSegment):void        {			this.aSegments.push(cs);        }				/**		 * returns the length of the Path elements array		 * 		 * @return	an integer: the length of the Path elements array		 */		public function get length():int        {			return this.aSegments.length;        }				/**		 * returns the Path elements array		 * 		 * @return	an Array: the Path elements array		 */		public function get array():Array        {			return this.aSegments;        }				/**		 * removes a segment in the path according to id.		 *		 * @param	 index	int. The index in path of the to be removed curvesegment 		 * @param	 join 		Boolean. If true previous and next segments coordinates are reconnected		 */		public function removeSegment(index:int, join:Boolean = false):void        {			if(this.aSegments.length == 0 || this.aSegments[index ] == null )				return;						if(join && index < this.aSegments.length-1 && index>0){				var seg:CurveSegment = this.aSegments[index];				var prevSeg:CurveSegment = this.aSegments[index-1];				var nextSeg:CurveSegment = this.aSegments[index+1];				prevSeg.vc.x = (prevSeg.vc.x+seg.vc.x)*.5;				prevSeg.vc.y = (prevSeg.vc.y+seg.vc.y)*.5;				prevSeg.vc.z = (prevSeg.vc.z+seg.vc.z)*.5;				nextSeg.vc.x = (nextSeg.vc.x+seg.vc.x)*.5;				nextSeg.vc.y = (nextSeg.vc.y+seg.vc.y)*.5;				nextSeg.vc.z = (nextSeg.vc.z+seg.vc.z)*.5;				prevSeg.v1.x = (seg.v0.x + seg.v1.x)*.5;				prevSeg.v1.y = (seg.v0.y + seg.v1.y)*.5;				prevSeg.v1.z = (seg.v0.z + seg.v1.z)*.5;				nextSeg.v0.x = prevSeg.v1.x;				nextSeg.v0.y = prevSeg.v1.y;				nextSeg.v0.z = prevSeg.v1.z;								if(_pathDebug != null)					_pathDebug.updateAnchorAt(index-1);					_pathDebug.updateAnchorAt(index+1);			}						if(this.aSegments.length > 1){				this.aSegments.splice(index, 1);			} else{				this.aSegments = [];			}        }				/**		 * handler will smooth the path using anchors as control vector of the CurveSegments 		 * note that this is not dynamic, the CurveSegments values are overwrited		 */		public function smoothPath():void        {			if(this.aSegments.length <= 2)				return;			 			_smoothed = true;			_averaged = false;			 			var x:Number;			var y:Number;			var z:Number;			var seg0:Number3D;			var seg1:Number3D;			var tmp:Array = [];			var i:int;						var startseg:Number3D = new Number3D(this.aSegments[0].v0.x, this.aSegments[0].v0.y, this.aSegments[0].v0.z);			var endseg:Number3D = new Number3D(this.aSegments[this.aSegments.length-1].v1.x, 																		this.aSegments[this.aSegments.length-1].v1.y,																		this.aSegments[this.aSegments.length-1].v1.z);			for(i = 0; i< length-1; ++i)			{				if(this.aSegments[i].vc == null)					this.aSegments[i].vc = this.aSegments[i].v1;								if(this.aSegments[i+1].vc == null)					this.aSegments[i+1].vc = this.aSegments[i+1].v1;								seg0 = this.aSegments[i].vc;				seg1 = this.aSegments[i+1].vc;				x = (seg0.x + seg1.x) * .5;				y = (seg0.y + seg1.y) * .5;				z = (seg0.z + seg1.z) * .5;								tmp.push( startseg,  new Number3D(seg0.x, seg0.y, seg0.z), new Number3D(x, y, z));				startseg = new Number3D(x, y, z);				this.aSegments[i] = null;			}						seg0 = this.aSegments[this.aSegments.length-1].vc;			tmp.push( startseg,  new Number3D((seg0.x+seg1.x)*.5, (seg0.y+seg1.y)*.5, (seg0.z+seg1.z)*.5), endseg);						this.aSegments[0] = null;			this.aSegments = [];						for(i = 0; i<tmp.length; i+=3)				this.aSegments.push( new CurveSegment(tmp[i], tmp[i+1], tmp[i+2]) );				tmp[i] = tmp[i+1] = tmp[i+2] = null;			 			tmp = null;		}				/**		 * handler will average the path using averages of the CurveSegments		 * note that this is not dynamic, the path values are overwrited		 */				public function averagePath():void        {			_averaged = true;			_smoothed = false;						for(var i:int = 0; i<this.aSegments.length; ++i){				this.aSegments[i].vc.x = (this.aSegments[i].v0.x+this.aSegments[i].v1.x)*.5;				this.aSegments[i].vc.y = (this.aSegments[i].v0.y+this.aSegments[i].v1.y)*.5;				this.aSegments[i].vc.z = (this.aSegments[i].v0.z+this.aSegments[i].v1.z)*.5;			}        }    }}